<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Libraries Guide: Create, Distribute, Consume</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>

<div class="container tutorial">

    <h1>The Complete Guide to C Static Libraries</h1>
    <p>This tutorial will take you from zero to having a distributable C library. We will cover creating the library, understanding the internals of linking, and consuming that library in a completely separate project.</p>

    <div class="note">
        <strong>The Core Concept:</strong> In C, a library is split into two parts:
        <ul>
            <li><strong>The Header (<code>.h</code>):</strong> The "Menu". It tells the compiler <em>what</em> functions are available.</li>
            <li><strong>The Archive (<code>.a</code>):</strong> The "Kitchen". It contains the compiled binary code (the implementation).</li>
        </ul>
    </div>

    <h2>Part 1: Creating the Library (`libgreet`)</h2>
    <p>We are building a library called <strong>libgreet</strong>. It has one job: saying hello.</p>

    <h3>1. Project Structure</h3>
    <pre>
libgreet/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ greeter.h      <span style="color:#888;">// The Public API</span>
â”œâ”€â”€ src/
â”‚   â””â”€â”€ greeter.c      <span style="color:#888;">// The Implementation</span>
â””â”€â”€ Makefile           <span style="color:#888;">// The Builder</span>
</pre>

    <h3>2. The Header File (API)</h3>
    <p>Create <code>include/greeter.h</code>. This is the contract you sign with the user.</p>
    <pre><code>#ifndef GREETER_H
#define GREETER_H

// Public API: Prints a greeting to stdout
void say_hello(const char *name);

#endif</code></pre>

    <h3>3. The Implementation</h3>
    <p>Create <code>src/greeter.c</code>. This is the actual logic.</p>
    <pre><code>#include &lt;stdio.h&gt;
#include "greeter.h"

void say_hello(const char *name) {
    printf("Hello, %s! Using a static library.\n", name);
}</code></pre>

    <h3>4. Building the Archive (The Makefile)</h3>
    <p>Create a <code>Makefile</code> in the root. This automates the complex compilation steps.</p>
    <pre><code>CC = gcc
CFLAGS = -Iinclude -Wall

# Target: The Static Library
libgreet.a: greeter.o
	ar rcs libgreet.a greeter.o

# Step 1: Compile Source to Object code
greeter.o: src/greeter.c
	$(CC) $(CFLAGS) -c src/greeter.c -o greeter.o

clean:
	rm -f *.o *.a</code></pre>

    <div class="internals">
        <h3>ğŸ” Internals: What just happened?</h3>
        <p>When you run <code>make</code>, two things happen at a low level:</p>
        <ol>
            <li><strong>Compilation (<code>-c</code>):</strong> The compiler translates <code>greeter.c</code> into machine code (<code>greeter.o</code>). However, this code is not executable yet. It's just a fragment.</li>
            <li><strong>Archiving (<code>ar</code>):</strong> The <code>ar</code> command acts like a ZIP tool. It takes <code>greeter.o</code> (and any other .o files you might have) and bundles them into a single file named <code>libgreet.a</code>. It adds an index (symbol table) so the Linker can find functions inside it later.</li>
        </ol>
    </div>

    <h2>Part 2: Distributing the Library</h2>
    <p>You have built the library. Now, how do you give it to a friend or use it in another project?</p>
    <p>You do not typically send the <code>.c</code> files. You send the <strong>Artifacts</strong>.</p>

    <div class="diagram">
   [Your Code]             [Distribution Package]
src/greeter.c  ---->  (DO NOT SEND)
include/greeter.h ->  include/greeter.h  (The Map)
libgreet.a     ---->  lib/libgreet.a     (The Treasure)
    </div>

    <p>To "distribute" this, you simply zip up the <code>include</code> folder and the <code>libgreet.a</code> file. That is your SDK.</p>

    <h2>Part 3: Consuming the Library (`my_game`)</h2>
    <p>Now, imagine you are a user who just downloaded your library. You want to use it in a completely new project.</p>

    <h3>1. The Consumer Folder Structure</h3>
    <p>Create a new folder <code>my_game</code> and organize the downloaded files into a <code>vendor</code> (or <code>deps</code>) folder.</p>
    <pre>
my_game/
â”œâ”€â”€ game.c               <span style="color:#888;">// Your new application</span>
â””â”€â”€ vendor/
    â”œâ”€â”€ include/
    â”‚   â””â”€â”€ greeter.h    <span style="color:#888;">// Copied from libgreet</span>
    â””â”€â”€ lib/
        â””â”€â”€ libgreet.a   <span style="color:#888;">// Copied from libgreet</span>
</pre>

    <h3>2. Writing the Client Code</h3>
    <p>Create <code>game.c</code>:</p>
    <pre><code>#include "greeter.h" 
// Note: We don't worry about WHERE greeter.h is yet. 
// That is the compiler's job.

int main() {
    say_hello("Player One");
    return 0;
}</code></pre>

    <h3>3. Compiling and Linking</h3>
    <p>This is the most critical step. If you run <code>gcc game.c</code>, it will fail. You must tell GCC where the parts are.</p>
    <pre><code>gcc game.c -I vendor/include -L vendor/lib -lgreet -o game</code></pre>

    <div class="internals">
        <h3>ğŸ” Deep Dive: The Compilation Internals</h3>
        <p>Let's break down exactly what the tools are doing with those flags:</p>
        
        <p><strong>1. The Preprocessor (<code>-I vendor/include</code>)</strong><br>
        Before compiling, the Preprocessor looks for <code>#include "greeter.h"</code>. It scans the folder <code>vendor/include</code>. When it finds the file, it literally <em>copy-pastes</em> the content of the header into your <code>game.c</code>. Now the compiler knows <code>say_hello</code> exists.</p>

        <p><strong>2. The Linker Search (<code>-L vendor/lib</code>)</strong><br>
        After compiling <code>game.c</code> into machine code, the code has a "hole". It calls <code>say_hello</code>, but the address of that function is empty. The Linker needs to fill that hole. The <code>-L</code> flag adds your vendor folder to the Linker's search path.</p>

        <p><strong>3. Symbol Resolution (<code>-lgreet</code>)</strong><br>
        The linker looks for a file strictly named <code>libgreet.a</code> (it adds 'lib' and '.a' automatically to whatever you type after -l). It opens that archive, finds the machine code for <code>say_hello</code>, and connects it to your main function.</p>
    </div>

    <h3>4. Run it</h3>
    <pre><code>./game
> Hello, Player One! Using a static library.</code></pre>

    <hr>
    
    <h2>Summary Checklist</h2>
    <ul>
        <li>âœ… <strong>Header (.h):</strong> Public interface. Tells the compiler definitions exist.</li>
        <li>âœ… <strong>Source (.c):</strong> Private implementation. Compiled into objects.</li>
        <li>âœ… <strong>Archive (.a):</strong> A bag of object files. This is your library.</li>
        <li>âœ… <strong>-I (Include):</strong> Tells compiler where to find headers.</li>
        <li>âœ… <strong>-L (Lib Path):</strong> Tells linker where to find library files.</li>
        <li>âœ… <strong>-l (Link):</strong> Tells linker which specific library to attach.</li>
    </ul>

</div>

</body>
</html>